// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Export Snapshot Tests > Conditional File Modifications > should modify styles.css import correctly based on isCliBuildTarget option > styles-css-cli 1`] = `
"@import 'tailwindcss' source('../../../');
@import './styles/global.css';

/* Base styles... */"
`;

exports[`Export Snapshot Tests > Conditional File Modifications > should modify styles.css import correctly based on isCliBuildTarget option > styles-css-ui 1`] = `
"@import 'tailwindcss';
@import './styles/global.css';

/* Base styles... */"
`;

exports[`Export Snapshot Tests > EVM Export Snapshots > should match snapshot for App component > app-component-evm 1`] = `
"import { EvmAdapter } from '@openzeppelin/transaction-form-adapter-evm';

import GeneratedForm from './components/GeneratedForm';

interface AppProps {
  adapter: EvmAdapter;
}

/**
 * App Component
 *
 * Main application component that wraps the form.
 */
export function App({ adapter }: AppProps) {
  return (
    <div className="app">
      <header className="header">
        <h1>Transaction Form for transfer</h1>
        <p>A form for interacting with blockchain contracts</p>
      </header>

      <main className="main">
        <div className="container">
          <GeneratedForm
            adapter={adapter}
            onSubmit={(data: FormData) => {
              console.log('Transaction submitted:', data);
              // Don't return a Promise, this function should be void
            }}
          />
        </div>
      </main>

      <footer className="footer">
        <p>Generated with OpenZeppelin Transaction Form Builder</p>
        <p>Â© 2025 OpenZeppelin</p>
      </footer>
    </div>
  );
}
"
`;

exports[`Export Snapshot Tests > EVM Export Snapshots > should match snapshot for EVM adapter > evm-adapter 1`] = `""`;

exports[`Export Snapshot Tests > EVM Export Snapshots > should match snapshot for Form component > form-component-evm 1`] = `
"import { useState } from 'react';

import { EvmAdapter } from '@openzeppelin/transaction-form-adapter-evm';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  ContractStateWidget,
  TransactionForm,
  WalletConnectionProvider,
} from '@openzeppelin/transaction-form-renderer';
import type {
  ContractSchema,
  FormFieldType,
  RenderFormSchema,
  TransactionFormProps,
} from '@openzeppelin/transaction-form-types';
import { logger } from '@openzeppelin/transaction-form-utils';

// Define type for transaction result (this will be implemented in the future)
interface TransactionResult {
  txHash?: string;
  error?: string;
}

// Define props for the component, extending TransactionFormProps but making schemas optional as they are injected by the generator
interface GeneratedFormProps extends Omit<TransactionFormProps, 'schema' | 'contractSchema'> {
  adapter: EvmAdapter;
}

/**
 * Generated Transaction Form for transfer
 *
 * This component renders a form for interacting with a blockchain contract.
 * It uses the shared form-renderer package which ensures consistent behavior
 * with the preview in the form builder.
 */
export default function GeneratedForm({ onSubmit, adapter }: GeneratedFormProps) {
  const [transactionResult, setTransactionResult] = useState<TransactionResult | null>(null);
  // const [contractSchema, setContractSchema] = useState<ContractSchema | null>(null);
  const [isWidgetVisible, setIsWidgetVisible] = useState(false);
  const [loadError, _setLoadError] = useState<Error | null>(null);

  // Form schema generated from the builder and transformed by FormSchemaFactory
  const formSchema: RenderFormSchema = {
    functionId: 'transfer',
    fields: [
      {
        id: '[id]',
        type: 'text',
        name: 'testParam',
        label: 'Test Parameter',
        helperText: 'Description for Test Parameter',
        placeholder: 'Enter test parameter',
        validation: {
          required: true,
        },
      },
    ],
    layout: {
      columns: 1,
      spacing: 'normal',
      labelPosition: 'top',
    },
    validation: {
      mode: 'onChange',
      showErrors: 'inline',
    },
    theme: {},
    contractAddress: '0xe34139463bA50bD61336E0c446Bd8C0867c6fE65',
    id: 'form-transfer',
    title: 'Transfer',
    description: 'Form for interacting with the Transfer function.',
    submitButton: {
      text: 'Execute Transfer',
      loadingText: 'Processing...',
      variant: 'primary',
    },
    defaultValues: {},
  };

  // Contract schema injected by generator (loaded or uploaded by the user)
  const contractSchema: ContractSchema = {
    ecosystem: 'evm',
    name: 'MockContract',
    address: '0x1234567890123456789012345678901234567890',
    functions: [
      {
        id: 'transfer',
        name: 'transfer',
        displayName: 'Transfer',
        inputs: [],
        type: 'function',
        modifiesState: true,
      },
      {
        id: 'viewFunction',
        name: 'viewFunction',
        displayName: 'View Function',
        inputs: [],
        type: 'function',
        modifiesState: false,
        stateMutability: 'view',
      },
    ],
  };

  // Original field configurations (including hidden, hardcoded values)
  const allFieldsConfig: FormFieldType[] = [
    {
      id: '[id]',
      type: 'text',
      name: 'testParam',
      label: 'Test Parameter',
      validation: {
        required: true,
      },
      helperText: 'Description for Test Parameter',
      placeholder: 'Enter test parameter',
    },
  ];

  // Execution configuration selected in the builder
  const executionConfig: unknown | undefined = {
    method: 'eoa',
    allowAny: true,
  };
  // TODO (Export Integration): Use executionConfig at runtime to determine
  // how to sign/broadcast (e.g., standard EOA signing, Safe interaction, relayer API).

  const contractAddress = formSchema.contractAddress;

  // TODO: Enable this useEffect as a fallback?
  // If the adapter supports runtime schema loading (e.g., via Etherscan)
  // and the injected schema is missing or invalid, this could attempt to load it.
  /*
  useEffect(() => {
    setLoadError(null);
    setContractSchema(null);

    if (contractAddress) {
      adapter
        .loadContract(contractAddress)
        .then(setContractSchema)
        .catch((err: unknown) => {
          // Catch error during contract loading
          logger.error('GeneratedForm', 'Error loading contract schema:', err);
          // Create a new Error object if caught value is not already one
          const errorToSet =
            err instanceof Error ? err : new Error('Failed to load contract state');
          setLoadError(errorToSet);
          setContractSchema(null);
        });
    } else {
      setContractSchema(null);
    }
  }, [contractAddress, adapter]);
  */

  // Decide which schema to use: prioritize injected, fallback maybe later?
  const schemaToUse = contractSchema; // Sticking to injected schema for now

  const toggleWidget = () => {
    setIsWidgetVisible((prev: boolean) => !prev);
  };

  // Handle form submission
  const handleSubmit = (formData: FormData) => {
    // Log the execution config (will be used for signing/broadcasting logic later)
    console.log('Using Execution Config:', executionConfig);

    // Convert FormData to Record<string, unknown> for adapter
    const submittedInputs: Record<string, unknown> = {};
    formData.forEach((value, key) => {
      submittedInputs[key] = value;
    });

    if (!schemaToUse) {
      console.error('handleSubmit: Contract schema is not available!');
      setTransactionResult({ error: 'Contract schema not loaded.' });
      return;
    }

    try {
      const functionId = 'transfer';
      const formattedData = adapter.formatTransactionData(
        schemaToUse,
        functionId,
        submittedInputs,
        allFieldsConfig
      );

      // --- Integration with onSubmit prop ---
      if (onSubmit) {
        // We might need to reconsider passing raw FormData if onSubmit expects the formatted data
        // For now, assume onSubmit handles the interaction
        onSubmit(formData);
        setTransactionResult({ txHash: '0x_SUBMITTED_VIA_PROP' }); // Indicate submission via prop
      } else {
        // --- Default submission logic (if no onSubmit provided) ---
        // This would typically involve signing and broadcasting
        console.log('Formatted data:', formattedData);
        // const result = await adapter.signAndBroadcast(formattedData);
        // setTransactionResult(result);
        // For template testing:
        setTransactionResult({ txHash: '0x_MOCK_TX_HASH' });
        logger.info('GeneratedForm', 'Mock submission successful!');
      }
    } catch (error) {
      logger.error('GeneratedForm', 'Submission error:', error);
      // TODO: Set an error state to display to the user
      setTransactionResult({ error: (error as Error).message });
    }
  };

  return (
    <WalletConnectionProvider adapter={adapter}>
      <div className="flex gap-4">
        <div className="flex-1">
          <Card>
            <CardHeader>
              {/* Render title unconditionally; React handles empty strings */}
              <CardTitle>{/*@@formSchema.title@@*/}</CardTitle>
              {/* Render description unconditionally */}
              <CardDescription>{/*@@formSchema.description@@*/}</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              {transactionResult && (
                <div className="transaction-result rounded-md bg-green-50 p-4 text-green-800">
                  <h3 className="font-medium">Transaction Successful!</h3>
                  <p className="mt-2 text-sm">
                    Transaction Hash: {transactionResult.txHash || 'N/A'}
                  </p>
                </div>
              )}
              {/* Check the actual contractAddress variable at runtime */}
              {contractAddress ? (
                <TransactionForm
                  schema={formSchema}
                  contractSchema={schemaToUse}
                  adapter={adapter}
                  onSubmit={handleSubmit}
                />
              ) : (
                <div className="text-destructive-foreground rounded-md bg-destructive p-4">
                  <h3 className="font-medium">Configuration Error</h3>
                  <p className="mt-2 text-sm">Missing contract address in the form schema.</p>
                </div>
              )}
            </CardContent>
          </Card>
        </div>

        {contractAddress && (
          <div className="w-[300px] flex-shrink-0">
            <div className="sticky top-4">
              <ContractStateWidget
                contractSchema={schemaToUse}
                contractAddress={contractAddress}
                adapter={adapter}
                isVisible={isWidgetVisible}
                onToggle={toggleWidget}
                error={loadError}
              />
            </div>
          </div>
        )}
      </div>
    </WalletConnectionProvider>
  );
}
"
`;

exports[`Export Snapshot Tests > EVM Export Snapshots > should match snapshot for adapters index > adapter-index-evm 1`] = `""`;

exports[`Export Snapshot Tests > EVM Export Snapshots > should match snapshot for package.json structure > package-json-evm 1`] = `
{
  "dependencies": {
    "@openzeppelin/transaction-form-adapter-evm": "^0.0.1",
    "@openzeppelin/transaction-form-renderer": "^1.0.0",
    "@openzeppelin/transaction-form-types": "^0.0.1",
    "@openzeppelin/transaction-form-utils": "^0.1.0",
    "lodash": "^4.17.21",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.54.2",
    "viem": "^2.28.0",
    "wagmi": "^2.15.0",
  },
  "devDependencies": {
    "@types/lodash": "^4.17.16",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.3",
    "@typescript-eslint/eslint-plugin": "^8.26.0",
    "@typescript-eslint/parser": "^8.26.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.17",
    "eslint": "^9.3.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.35",
    "tailwindcss": "^4.0.0",
    "typescript": "^5.8.2",
    "vite": "^6.2.5",
  },
  "scripts": {
    "build": "tsc && vite build",
    "check-deps": "npm outdated",
    "dev": "vite",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "update-form-renderer": "npm update @openzeppelin/transaction-form-renderer",
  },
}
`;

exports[`Export Snapshot Tests > Solana Export Snapshots > should match snapshot for Solana adapter > solana-adapter 1`] = `""`;

exports[`Export Snapshot Tests > Solana Export Snapshots > should match snapshot for adapters index with Solana > adapter-index-solana 1`] = `""`;

exports[`Export Snapshot Tests > Solana Export Snapshots > should match snapshot for package.json with Solana dependencies > package-json-solana 1`] = `
{
  "dependencies": {
    "@openzeppelin/transaction-form-adapter-evm": "^0.0.1",
    "@openzeppelin/transaction-form-renderer": "^1.0.0",
    "@openzeppelin/transaction-form-types": "^0.0.1",
    "@openzeppelin/transaction-form-utils": "^0.1.0",
    "lodash": "^4.17.21",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.54.2",
    "viem": "^2.28.0",
    "wagmi": "^2.15.0",
  },
  "devDependencies": {
    "@types/lodash": "^4.17.16",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.3",
    "@typescript-eslint/eslint-plugin": "^8.26.0",
    "@typescript-eslint/parser": "^8.26.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.17",
    "eslint": "^9.3.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.35",
    "tailwindcss": "^4.0.0",
    "typescript": "^5.8.2",
    "vite": "^6.2.5",
  },
  "scripts": {
    "build": "tsc && vite build",
    "check-deps": "npm outdated",
    "dev": "vite",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "update-form-renderer": "npm update @openzeppelin/transaction-form-renderer",
  },
}
`;

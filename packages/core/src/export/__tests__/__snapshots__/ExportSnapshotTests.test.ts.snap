// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Export Snapshot Tests > Conditional File Modifications > should modify styles.css import correctly based on isCliBuildTarget option > styles-css-cli 1`] = `
"@import 'tailwindcss' source('../../../');
@import './styles/global.css';

/* Base styles... */"
`;

exports[`Export Snapshot Tests > Conditional File Modifications > should modify styles.css import correctly based on isCliBuildTarget option > styles-css-ui 1`] = `
"@import 'tailwindcss';
@import './styles/global.css';

/* Base styles... */"
`;

exports[`Export Snapshot Tests > EVM Export Snapshots > should match snapshot for App component > app-component-evm 1`] = `
"import GeneratedForm from './components/GeneratedForm';

// Define types for the transaction data
interface TransactionData {
  [key: string]: unknown;
}

/**
 * App Component
 *
 * Main application component that wraps the form.
 */
export function App() {
  return (
    <div className="app">
      <header className="header">
        <h1>Transaction Form for transfer</h1>
        <p>A form for interacting with blockchain contracts</p>
      </header>

      <main className="main">
        <div className="container">
          <GeneratedForm
            onSubmit={(txData: TransactionData) => {
              console.log('Transaction submitted:', txData);
              return Promise.resolve({ txHash: 'demo-tx-hash-' + Date.now() });
            }}
            onError={(error: Error) => {
              console.error('Transaction error:', error);
            }}
          />
        </div>
      </main>

      <footer className="footer">
        <p>Generated with OpenZeppelin Transaction Form Builder</p>
        <p>Â© 2025 OpenZeppelin</p>
      </footer>
    </div>
  );
}
"
`;

exports[`Export Snapshot Tests > EVM Export Snapshots > should match snapshot for EVM adapter > evm-adapter 1`] = `
"import type { GetAccountReturnType } from '@wagmi/core';
import { Contract, JsonRpcProvider, isAddress } from 'ethers';
import { startCase } from 'lodash';

import { generateId, logger } from '@openzeppelin/transaction-form-renderer';
import type { Connector } from '@openzeppelin/transaction-form-types/adapters';
import type {
  ContractSchema,
  FunctionParameter,
} from '@openzeppelin/transaction-form-types/contracts';
import type {
  FieldType,
  FieldValue,
  FormFieldType,
} from '@openzeppelin/transaction-form-types/forms';

import MockContractService from '../../services/MockContractService';
import type { MockContractInfo } from '../../services/MockContractService';
import type {
  ContractAdapter,
  ContractFunction,
  ExecutionConfig,
  ExecutionMethodDetail,
} from '../index';

import { WagmiWalletImplementation } from './wallet-connect/wagmi-implementation';

import type { AbiItem } from './types';

/**
 * EVM-specific type mapping
 */
const EVM_TYPE_TO_FIELD_TYPE: Record<string, FieldType> = {
  address: 'blockchain-address',
  string: 'text',
  uint: 'number',
  uint8: 'number',
  uint16: 'number',
  uint32: 'number',
  uint64: 'number',
  uint128: 'number',
  uint256: 'number',
  int: 'number',
  int8: 'number',
  int16: 'number',
  int32: 'number',
  int64: 'number',
  int128: 'number',
  int256: 'number',
  bool: 'checkbox',
  bytes: 'textarea',
  bytes32: 'text',
};

/**
 * EVM-specific adapter implementation
 */
export class EvmAdapter implements ContractAdapter {
  /**
   * Private implementation of wallet connection using Wagmi
   */
  private walletImplementation: WagmiWalletImplementation;

  constructor() {
    // Initialize the Wagmi wallet implementation
    this.walletImplementation = new WagmiWalletImplementation();
  }

  /**
   * @inheritdoc
   */
  async loadContract(source: string): Promise<ContractSchema> {
    // Step 1: Input Type Detection
    if (isAddress(source)) {
      // Input is likely an address, attempt Etherscan fetch
      logger.info('EvmAdapter', \`Detected address: \${source}. Attempting Etherscan ABI fetch...\`);
      return this.loadAbiFromEtherscan(source);
    } else {
      // Input is likely a JSON ABI string (or potentially invalid)
      logger.info('EvmAdapter', 'Input is not an address. Attempting to parse as JSON ABI...');
      // Assume input is JSON string if not an address
      return this.loadAbiFromJson(source);
    }
  }

  /**
   * Loads and parses an ABI directly from a JSON string.
   */
  private async loadAbiFromJson(abiJsonString: string): Promise<ContractSchema> {
    let abi: AbiItem[];
    try {
      abi = JSON.parse(abiJsonString);
      if (!Array.isArray(abi)) {
        throw new Error('Parsed JSON is not an array.');
      }
      // TODO: Add more robust ABI structure validation if needed
    } catch (error) {
      logger.error('EvmAdapter', 'Failed to parse source string as JSON ABI:', error);
      throw new Error(\`Invalid JSON ABI provided: \${(error as Error).message}\`);
    }

    logger.info('EvmAdapter', \`Successfully parsed JSON ABI with \${abi.length} items.\`);
    const contractName = 'ContractFromABI'; // Default name for direct ABI
    return this.transformAbiToSchema(abi, contractName, undefined);
  }

  /**
   * Fetches and parses an ABI from Etherscan using a contract address.
   */
  private async loadAbiFromEtherscan(address: string): Promise<ContractSchema> {
    const apiKey = import.meta.env.VITE_ETHERSCAN_API_KEY;
    if (!apiKey) {
      logger.error('EvmAdapter', 'Etherscan API Key (VITE_ETHERSCAN_API_KEY) is missing.');
      throw new Error('Etherscan API Key is not configured.');
    }

    // TODO: Make network dynamic
    const apiBaseUrl = 'https://api.etherscan.io/api'; // Mainnet default
    const url = \`\${apiBaseUrl}?module=contract&action=getabi&address=\${address}&apikey=\${apiKey}\`;

    let response: Response;
    try {
      logger.info('EvmAdapter', \`Fetching ABI from Etherscan for address: \${address}\`);
      response = await fetch(url);
    } catch (networkError) {
      logger.error('EvmAdapter', 'Network error fetching ABI from Etherscan:', networkError);
      throw new Error(\`Network error fetching ABI: \${(networkError as Error).message}\`);
    }

    if (!response.ok) {
      logger.error('EvmAdapter', \`Etherscan API request failed with status: \${response.status}\`);
      throw new Error(\`Etherscan API request failed: \${response.status} \${response.statusText}\`);
    }

    let etherscanResult: { status: string; message: string; result: string };
    try {
      etherscanResult = await response.json();
    } catch (jsonError) {
      logger.error('EvmAdapter', 'Failed to parse Etherscan API response as JSON:', jsonError);
      throw new Error('Invalid JSON response received from Etherscan API.');
    }

    if (etherscanResult.status !== '1') {
      logger.warn(
        'EvmAdapter',
        \`Etherscan API error: Status \${etherscanResult.status}, Result: \${etherscanResult.result}\`
      );
      if (etherscanResult.result?.includes('Contract source code not verified')) {
        throw new Error(
          \`Contract not verified on Etherscan (address: \${address}). ABI not available.\`
        );
      }
      throw new Error(\`Etherscan API Error: \${etherscanResult.result || etherscanResult.message}\`);
    }

    let abi: AbiItem[];
    try {
      abi = JSON.parse(etherscanResult.result);
      if (!Array.isArray(abi)) {
        throw new Error('Parsed ABI from Etherscan is not an array.');
      }
    } catch (error) {
      logger.error('EvmAdapter', 'Failed to parse ABI JSON string from Etherscan result:', error);
      throw new Error(\`Invalid ABI JSON received from Etherscan: \${(error as Error).message}\`);
    }

    logger.info('EvmAdapter', \`Successfully parsed Etherscan ABI with \${abi.length} items.\`);
    // TODO: Fetch contract name?
    const contractName = \`Contract_\${address.substring(0, 6)}\`;
    return this.transformAbiToSchema(abi, contractName, address);
  }

  /**
   * Transforms a standard ABI array into the ContractSchema format.
   * @param abi The ABI array to transform
   * @param contractName The name to use for the contract
   * @param address Optional contract address to include in the schema
   */
  private transformAbiToSchema(
    abi: AbiItem[],
    contractName: string,
    address?: string
  ): ContractSchema {
    logger.info('EvmAdapter', \`Transforming ABI to ContractSchema for: \${contractName}\`);
    const contractSchema: ContractSchema = {
      chainType: 'evm',
      name: contractName,
      address,
      functions: abi
        .filter((item) => item.type === 'function')
        .map((item) => ({
          id: \`\${item.name}_\${item.inputs?.map((i) => i.type).join('_') || ''}\`,
          name: item.name || '',
          displayName: this.formatMethodName(item.name || ''),
          inputs:
            item.inputs?.map((input) => ({
              name: input.name,
              type: input.type,
              displayName: this.formatInputName(input.name, input.type),
            })) || [],
          type: item.type || 'function',
          stateMutability: item.stateMutability,
          modifiesState: !item.stateMutability || !['view', 'pure'].includes(item.stateMutability),
        })),
    };
    logger.info(
      'EvmAdapter',
      \`Transformation complete. Found \${contractSchema.functions.length} functions.\`
    );
    return contractSchema;
  }

  /**
   * @inheritdoc
   */
  mapParameterTypeToFieldType(parameterType: string): FieldType {
    // Check if this is an array type (ends with [] or [number])
    if (parameterType.match(/\\[\\d*\\]$/)) {
      // All array types should use textarea for JSON input
      return 'textarea';
    }

    // Extract the base type from array types (e.g., uint256[] -> uint256)
    const baseType = parameterType.replace(/\\[\\d*\\]/g, '');

    // Handle tuples (structs) - for now, just use a textarea
    if (baseType.startsWith('tuple')) {
      return 'textarea';
    }

    // Map common EVM types to appropriate field types
    return EVM_TYPE_TO_FIELD_TYPE[baseType] || 'text';
  }

  /**
   * @inheritdoc
   */
  getCompatibleFieldTypes(parameterType: string): FieldType[] {
    // Handle array and tuple types
    if (parameterType.match(/\\[\\d*\\]$/)) {
      return ['textarea', 'text'];
    }

    const baseType = parameterType.replace(/\\[\\d*\\]/g, '');

    if (baseType.startsWith('tuple')) {
      return ['textarea', 'text'];
    }

    // Define compatibility map
    const compatibilityMap: Record<string, FieldType[]> = {
      address: ['blockchain-address', 'text'],
      uint: ['number', 'amount', 'text'],
      uint8: ['number', 'amount', 'text'],
      uint16: ['number', 'amount', 'text'],
      uint32: ['number', 'amount', 'text'],
      uint64: ['number', 'amount', 'text'],
      uint128: ['number', 'amount', 'text'],
      uint256: ['number', 'amount', 'text'],
      int: ['number', 'text'],
      int8: ['number', 'text'],
      int16: ['number', 'text'],
      int32: ['number', 'text'],
      int64: ['number', 'text'],
      int128: ['number', 'text'],
      int256: ['number', 'text'],
      bool: ['checkbox', 'select', 'radio', 'text'],
      string: ['text', 'textarea', 'email', 'password'],
      bytes: ['textarea', 'text'],
      bytes32: ['text', 'textarea'],
    };

    return compatibilityMap[baseType] || ['text'];
  }

  /**
   * @inheritdoc
   */
  generateDefaultField<T extends FieldType = FieldType>(
    parameter: FunctionParameter
  ): FormFieldType<T> {
    // Get the field type
    const fieldType = this.mapParameterTypeToFieldType(parameter.type) as T;

    // Create a default field based on the parameter with proper typing
    return {
      id: generateId(),
      name: parameter.name || parameter.type,
      label: startCase(parameter.displayName || parameter.name || parameter.type),
      type: fieldType,
      placeholder: \`Enter \${parameter.displayName || parameter.name || parameter.type}\`,
      helperText: parameter.description || '',
      defaultValue: this.getDefaultValueForType(fieldType) as FieldValue<T>,
      validation: this.getDefaultValidationForType(parameter.type),
      width: 'full',
    };
  }

  /**
   * Get a default value for a field type
   * @param fieldType The form field type
   * @returns An appropriate default value
   */
  private getDefaultValueForType<T extends FieldType>(fieldType: T): FieldValue<T> {
    switch (fieldType) {
      case 'checkbox':
        return false as FieldValue<T>;
      case 'number':
      case 'amount':
        return 0 as FieldValue<T>;
      case 'blockchain-address':
        return '' as FieldValue<T>;
      default:
        return '' as FieldValue<T>;
    }
  }

  /**
   * Get default validation rules for a parameter type
   * @param parameterType The EVM parameter type
   * @returns Validation rules appropriate for the type
   */
  private getDefaultValidationForType(parameterType: string): {
    required?: boolean;
    pattern?: string;
    minLength?: number;
    maxLength?: number;
    custom?: (value: unknown) => boolean | string;
  } {
    const validation = { required: true };

    // Add specific validation rules based on the parameter type
    if (parameterType === 'blockchain-address') {
      return {
        ...validation,
        // Use the adapter's isValidAddress method for direct validation
        custom: (value: unknown): boolean | string => {
          // Empty values are handled by the required property
          if (value === '') return true;

          // We expect addresses to be strings
          if (typeof value !== 'string') return 'Address must be a string';

          // Validate the address format using the adapter's method
          return this.isValidAddress(value) ? true : 'Invalid address format';
        },
      };
    }

    return validation;
  }

  /**
   * @inheritdoc
   */
  formatTransactionData(
    functionId: string,
    submittedInputs: Record<string, unknown>,
    allFieldsConfig: FormFieldType[]
  ): unknown {
    /*
     * TODO: Implement Full Hardcoded Value Merging and EVM ABI Encoding
     *
     * This function needs to construct the final ordered array of arguments
     * expected by the EVM function call, considering both user-submitted
     * data and hardcoded values defined in the configuration.
     *
     * Steps:
     * 1. Determine Argument Order: The order must match the function signature in the ABI.
     *    - It might be necessary to retrieve the original ABI definition for \`functionId\` here.
     *    - Alternatively, if \`allFieldsConfig\` preserves the original parameter order reliably,
     *      it can be used as the source of truth for iteration.
     *
     * 2. Iterate Through Expected Parameters (in order):
     *    - For each expected parameter:
     *      a. Find the corresponding field configuration in \`allFieldsConfig\` (using \`field.name\`).
     *      b. Check \`field.isHardcoded\`.
     *      c. If \`true\`, use \`field.hardcodedValue\`.
     *      d. If \`false\`, retrieve the value from \`submittedInputs\` using \`field.name\`.
     *      e. Handle cases where a non-hardcoded field might be missing from \`submittedInputs\`
     *         (this shouldn't happen if \`isHidden\` logic is correct, but add defensive checks).
     *
     * 3. Apply Type Transformations:
     *    - Based on the original EVM parameter type (e.g., \`field.originalParameterType\` or
     *      looked up from the ABI), convert the selected value (hardcoded or submitted)
     *      to the type expected by the encoding library (e.g., ethers.js).
     *    - Examples:
     *      - 'uint256': Convert string/number from form/hardcoded value to \`BigInt\`.
     *      - 'address': Ensure correct casing (checksummed) via \`ethers.getAddress()\`.
     *      - 'bool': Ensure value is \`true\` or \`false\`.
     *      - 'bytes': Convert hex string to appropriate format.
     *      - Arrays/Structs: Parse JSON strings (if textarea was used) or handle appropriately.
     *      - Use \`field.transforms?.output\` if available for custom transformations.
     *
     * 4. EVM ABI Encode (using ethers.js or similar):
     *    - Use a library like \`ethers.js\` (\`Interface\` class or \`AbiCoder\`)
     *      to encode the function selector and the prepared, ordered, type-corrected arguments
     *      into the final transaction \`data\` payload (hex string).
     *
     * 5. Return Formatted Transaction Object:
     *    - Return an object suitable for the next step (signing/broadcasting),
     *      including the \`to\` address (contract address), \`data\` (encoded payload),
     *      \`value\` (if payable), etc.
     */

    // --- Current Placeholder Logic ---
    console.log(\`Formatting EVM transaction data for function: \${functionId}\`);
    console.log('Submitted Inputs:', submittedInputs);
    console.log('All Fields Config:', allFieldsConfig);

    // Filter/map config for debugging (optional)
    const hardcoded = allFieldsConfig
      .filter((f) => f.isHardcoded)
      .map((f) => ({ name: f.name, value: f.hardcodedValue }));
    const hidden = allFieldsConfig.filter((f) => f.isHidden).map((f) => f.name);
    console.log('Hardcoded fields:', hardcoded);
    console.log('Hidden fields:', hidden);

    // Placeholder return - Replace with actual encoded data
    return {
      to: '0x1234567890123456789012345678901234567890', // Replace with actual contract address
      data: \`0x\${functionId.substring(0, 8)}0000...\`, // Placeholder - Replace with encoded function call
      value: '0', // Replace if payable
      gasLimit: '100000', // Example gas limit
    };
  }

  /**
   * @inheritdoc
   */
  async signAndBroadcast(transactionData: unknown): Promise<{ txHash: string }> {
    // In a real implementation, this would use ethers.js or web3.js to sign and broadcast
    console.log('Signing and broadcasting EVM transaction:', transactionData);

    // Return a mock transaction hash
    return {
      txHash: \`0x\${Math.random().toString(16).substring(2, 42)}\`,
    };
  }

  /**
   * Format a method name for display
   */
  private formatMethodName(name: string): string {
    return name
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, (str) => str.toUpperCase())
      .trim();
  }

  /**
   * Format an input name for display
   */
  private formatInputName(name: string, type: string): string {
    if (!name || name === '') {
      return \`Parameter (\${type})\`;
    }
    return name
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, (str) => str.toUpperCase())
      .replace(/_/g, ' ')
      .trim();
  }

  /**
   * @inheritdoc
   */
  getWritableFunctions(contractSchema: ContractSchema): ContractSchema['functions'] {
    return contractSchema.functions.filter((fn) => fn.modifiesState);
  }

  /**
   * @inheritdoc
   */
  isValidAddress(address: string): boolean {
    return isAddress(address);
  }

  /**
   * @inheritdoc
   * TODO: Implement actual supported methods for EVM (e.g., EOA, Safe).
   */
  public async getSupportedExecutionMethods(): Promise<ExecutionMethodDetail[]> {
    // Placeholder: Assume only EOA is supported for now
    console.warn('EVMAdapter.getSupportedExecutionMethods is using placeholder implementation.');
    return Promise.resolve([
      {
        type: 'eoa',
        name: 'EOA (External Account)',
        description: 'Execute using a standard wallet address.',
      },
      {
        type: 'multisig',
        name: 'Safe Multisig', // Example for future
        description: 'Execute via a Safe multisignature wallet.',
        disabled: false, // Enable for UI testing, even if not fully implemented
      },
      // Add a basic relayer placeholder for UI testing
      {
        type: 'relayer',
        name: 'Relayer (Placeholder)',
        description: 'Execute via a OpenZeppelin transaction relayer (not yet implemented).',
        disabled: false, // Enable for UI testing, even if not fully implemented
      },
    ]);
  }

  /**
   * @inheritdoc
   * TODO: Implement actual validation logic for EVM execution configs.
   */
  public async validateExecutionConfig(config: ExecutionConfig): Promise<true | string> {
    console.warn('EVMAdapter.validateExecutionConfig is using placeholder implementation.');

    switch (config.method) {
      case 'eoa': {
        if (!config.allowAny) {
          if (!config.specificAddress) {
            return 'Specific EOA address is required.';
          }
          if (!this.isValidAddress(config.specificAddress)) {
            return 'Invalid EOA address format.';
          }
        }
        return true; // Placeholder: EOA config is valid if address format is okay
      }
      case 'multisig': {
        // Placeholder: Accept multisig config for now
        // TODO: Add Safe-specific validation (e.g., check if address is a valid Safe)
        return true;
      }
      case 'relayer': {
        // Placeholder: Accept relayer config for now
        // TODO: Add relayer-specific validation
        return true;
      }
      default: {
        // This handles the 'never' case for exhaustive checks
        const exhaustiveCheck: never = config;
        return \`Unsupported execution method type: \${(exhaustiveCheck as ExecutionConfig).method}\`;
      }
    }
  }

  /**
   * @inheritdoc
   */
  async loadMockContract(mockId?: string): Promise<ContractSchema> {
    try {
      const mocks = await MockContractService.getAvailableMocks();
      const mockInfo = mockId
        ? mocks.find((mock: MockContractInfo) => mock.id === mockId)
        : mocks.find((mock: MockContractInfo) => mock.id === 'input-tester');

      if (!mockInfo) {
        throw new Error(\`Mock contract with ID \${mockId || 'input-tester'} not found\`);
      }

      const mockAbi = (await MockContractService.getMockAbi(mockInfo.file)) as AbiItem[];
      const contractName = mockInfo.name;

      // Always provide a valid address for test schemas
      const address = '0x1234567890123456789012345678901234567890';
      return this.transformAbiToSchema(mockAbi, contractName, address);
    } catch (error) {
      // Type assertion for error message
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error('EvmAdapter', 'Error loading mock EVM contract:', errorMessage);
      throw new Error('Failed to load mock EVM contract');
    }
  }

  /**
   * @inheritdoc
   */
  isViewFunction(functionDetails: ContractFunction): boolean {
    return functionDetails.stateMutability === 'view' || functionDetails.stateMutability === 'pure';
  }

  /**
   * @inheritdoc
   */
  async queryViewFunction(
    contractAddress: string,
    functionId: string,
    params: unknown[] = [],
    contractSchema?: ContractSchema
  ): Promise<unknown> {
    try {
      // Validate contract address
      if (!contractAddress || contractAddress.trim() === '') {
        throw new Error('Contract address is empty or not provided');
      }

      if (!isAddress(contractAddress)) {
        throw new Error(\`Invalid Ethereum address: \${contractAddress}\`);
      }

      // Use ethers.js to create a contract instance
      const provider = new JsonRpcProvider(
        // Use a reliable public RPC URL that allows CORS
        // TODO: Make this configurable
        import.meta.env.VITE_RPC_URL || 'https://eth.llamarpc.com'
      );

      // Use provided schema or load it
      const schema = contractSchema || (await this.loadContract(contractAddress));

      // Find the function in the schema
      const functionDetails = schema.functions.find((fn) => fn.id === functionId);
      if (!functionDetails) {
        throw new Error(\`Function with ID \${functionId} not found\`);
      }

      // Create minimal ABI for just this function with generic bytes output
      // TODO: Add support for a better formatting of the output (formatFunctionResult)
      const genericAbi = [
        {
          name: functionDetails.name,
          type: 'function',
          stateMutability: functionDetails.stateMutability || 'view',
          inputs: functionDetails.inputs.map((i) => ({ name: i.name, type: i.type })),
          outputs: [{ name: '', type: 'bytes' }],
        },
      ];

      // Create contract interface
      const genericContract = new Contract(contractAddress, genericAbi, provider);

      // Just make the raw call and return the result
      const rawResult = await provider.call({
        to: contractAddress,
        data: genericContract.interface.encodeFunctionData(functionDetails.name, params),
      });

      // TODO: Add support for a better formatting of the output (formatFunctionResult)
      return rawResult;
    } catch (error) {
      console.error('Error querying view function:', error);
      throw error;
    }
  }

  /**
   * @inheritdoc
   */
  formatFunctionResult(
    result: unknown,
    _functionDetails: ContractFunction
  ): string | Record<string, unknown> {
    // Existing implementation...
    if (result === null || result === undefined) {
      return 'No data';
    }

    // Special handling for BigInt values
    if (typeof result === 'bigint') {
      return result.toString();
    }

    return String(result);
  }

  /**
   * @inheritdoc
   */
  supportsWalletConnection(): boolean {
    return true; // EVM adapter supports wallet connection via Wagmi
  }

  /**
   * @inheritdoc
   */
  async getAvailableConnectors(): Promise<Connector[]> {
    return this.walletImplementation.getAvailableConnectors();
  }

  /**
   * @inheritdoc
   */
  async connectWallet(
    connectorId: string
  ): Promise<{ connected: boolean; address?: string; error?: string }> {
    // Delegate to the Wagmi implementation
    return this.walletImplementation.connect(connectorId);
  }

  /**
   * @inheritdoc
   */
  async disconnectWallet(): Promise<{ disconnected: boolean; error?: string }> {
    // Delegate to the Wagmi implementation
    return this.walletImplementation.disconnect();
  }

  /**
   * @inheritdoc
   */
  getWalletConnectionStatus(): { isConnected: boolean; address?: string; chainId?: string } {
    // Delegate to the Wagmi implementation and map the result
    const status = this.walletImplementation.getWalletConnectionStatus();
    return {
      isConnected: status.isConnected,
      address: status.address,
      // Convert chainId from number to string for the interface
      chainId: status.chainId?.toString(),
    };
  }

  /**
   * @inheritdoc
   */
  onWalletConnectionChange(
    callback: (account: GetAccountReturnType, prevAccount: GetAccountReturnType) => void
  ): () => void {
    // Delegate to the Wagmi implementation
    return this.walletImplementation.onWalletConnectionChange(callback);
  }

  /**
   * @inheritdoc
   */
  getExplorerUrl(address: string, _chainId?: string): string | null {
    // TODO: Enhance this to use the actual connected chainId from getWalletConnectionStatus
    // and potentially support multiple explorers based on the chain.
    // For now, defaults to Etherscan (Mainnet).
    if (!this.isValidAddress(address)) return null;
    return \`https://etherscan.io/address/\${address}\`;
  }
}

// Also export as default to ensure compatibility with various import styles
export default EvmAdapter;
"
`;

exports[`Export Snapshot Tests > EVM Export Snapshots > should match snapshot for Form component > form-component-evm 1`] = `
"import { useEffect, useMemo, useState } from 'react';

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  ContractStateWidget,
  TransactionForm,
  logger,
} from '@openzeppelin/transaction-form-renderer';
import type { ContractSchema } from '@openzeppelin/transaction-form-types/contracts';
import type {
  FormFieldType,
  RenderFormSchema,
  TransactionFormProps,
} from '@openzeppelin/transaction-form-types/forms';

import { EvmAdapter } from '../adapters/evm/adapter';

// Define type for transaction result (this will be implemented in the future)
interface TransactionResult {
  txHash?: string;
  error?: string;
}

/**
 * Generated Transaction Form for transfer
 *
 * This component renders a form for interacting with a blockchain contract.
 * It uses the shared form-renderer package which ensures consistent behavior
 * with the preview in the form builder.
 */
export default function GeneratedForm({ onSubmit }: TransactionFormProps) {
  const [transactionResult, setTransactionResult] = useState<TransactionResult | null>(null);
  const [contractSchema, setContractSchema] = useState<ContractSchema | null>(null);
  const [isWidgetVisible, setIsWidgetVisible] = useState(false);
  const [loadError, setLoadError] = useState<Error | null>(null);

  // Create the adapter instance for evm
  const adapter = useMemo(() => new EvmAdapter(), []);

  // Form schema generated from the builder and transformed by FormSchemaFactory
  const formSchema: RenderFormSchema = {
    functionId: 'transfer',
    fields: [
      {
        id: '[id]',
        type: 'text',
        name: 'testParam',
        label: 'Test Parameter',
        helperText: 'Description for Test Parameter',
        placeholder: 'Enter test parameter',
        validation: {
          required: true,
        },
      },
    ],
    layout: {
      columns: 1,
      spacing: 'normal',
      labelPosition: 'top',
    },
    validation: {
      mode: 'onChange',
      showErrors: 'inline',
    },
    executionConfig: {
      method: 'eoa',
      allowAny: true,
    },
    theme: {},
    contractAddress: '0xe34139463bA50bD61336E0c446Bd8C0867c6fE65',
    id: 'form-transfer',
    title: 'transfer',
    description: 'Form for interacting with the transfer function.',
    submitButton: {
      text: 'Execute transfer',
      loadingText: 'Processing...',
      variant: 'primary',
    },
    defaultValues: {},
  };

  // Original field configurations (including hidden, hardcoded values)
  const allFieldsConfig: FormFieldType[] = [
    {
      id: '[id]',
      type: 'text',
      name: 'testParam',
      label: 'Test Parameter',
      validation: {
        required: true,
      },
      helperText: 'Description for Test Parameter',
      placeholder: 'Enter test parameter',
    },
  ];

  // Execution configuration selected in the builder
  const executionConfig: unknown | undefined = {
    method: 'eoa',
    allowAny: true,
  };
  // TODO (Export Integration): Use executionConfig at runtime to determine
  // how to sign/broadcast (e.g., standard EOA signing, Safe interaction, relayer API).

  const contractAddress = formSchema.contractAddress;

  useEffect(() => {
    setLoadError(null);
    setContractSchema(null);

    if (contractAddress) {
      adapter
        .loadContract(contractAddress)
        .then(setContractSchema)
        .catch((err: unknown) => {
          // Catch error during contract loading
          logger.error('GeneratedForm', 'Error loading contract schema:', err);
          // Create a new Error object if caught value is not already one
          const errorToSet =
            err instanceof Error ? err : new Error('Failed to load contract state');
          setLoadError(errorToSet);
          setContractSchema(null);
        });
    } else {
      setContractSchema(null);
    }
  }, [contractAddress, adapter]);

  const toggleWidget = () => {
    setIsWidgetVisible((prev: boolean) => !prev);
  };

  // Handle form submission - remove async for now
  const handleSubmit = (formData: FormData) => {
    // Log the execution config (will be used for signing/broadcasting logic later)
    console.log('Using Execution Config:', executionConfig);

    // Convert FormData to Record<string, unknown> for adapter
    const submittedInputs: Record<string, unknown> = {};
    formData.forEach((value, key) => {
      submittedInputs[key] = value;
    });

    try {
      const functionId = 'transfer';
      // Format data using the adapter, passing the original field configurations
      const formattedData = adapter.formatTransactionData(
        functionId,
        submittedInputs,
        allFieldsConfig // Pass the original config here
      );

      // --- Integration with onSubmit prop ---
      if (onSubmit) {
        // We might need to reconsider passing raw FormData if onSubmit expects the formatted data
        // For now, assume onSubmit handles the interaction
        onSubmit(formData);
        setTransactionResult({ txHash: '0x_SUBMITTED_VIA_PROP' }); // Indicate submission via prop
      } else {
        // --- Default submission logic (if no onSubmit provided) ---
        // This would typically involve signing and broadcasting
        console.log('Formatted data:', formattedData);
        // const result = await adapter.signAndBroadcast(formattedData);
        // setTransactionResult(result);
        // For template testing:
        setTransactionResult({ txHash: '0x_MOCK_TX_HASH' });
        logger.info('GeneratedForm', 'Mock submission successful!');
      }
    } catch (error) {
      logger.error('GeneratedForm', 'Submission error:', error);
      // TODO: Set an error state to display to the user
      setTransactionResult({ error: (error as Error).message });
    }
  };

  return (
    <div className="flex gap-4">
      <div className="flex-1">
        <Card>
          <CardHeader>
            {/* Render title unconditionally; React handles empty strings */}
            <CardTitle>{/*@@formSchema.title@@*/}</CardTitle>
            {/* Render description unconditionally */}
            <CardDescription>{/*@@formSchema.description@@*/}</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {transactionResult && (
              <div className="transaction-result rounded-md bg-green-50 p-4 text-green-800">
                <h3 className="font-medium">Transaction Successful!</h3>
                <p className="mt-2 text-sm">
                  Transaction Hash: {transactionResult.txHash || 'N/A'}
                </p>
              </div>
            )}
            {/* Check the actual contractAddress variable at runtime */}
            {contractAddress ? (
              <TransactionForm schema={formSchema} adapter={adapter} onSubmit={handleSubmit} />
            ) : (
              <div className="text-destructive-foreground rounded-md bg-destructive p-4">
                <h3 className="font-medium">Configuration Error</h3>
                <p className="mt-2 text-sm">Missing contract address in the form schema.</p>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      {contractAddress && (
        <div className="w-[300px] flex-shrink-0">
          <div className="sticky top-4">
            <ContractStateWidget
              contractSchema={contractSchema}
              contractAddress={contractAddress}
              adapter={adapter}
              isVisible={isWidgetVisible}
              onToggle={toggleWidget}
              error={loadError}
            />
          </div>
        </div>
      )}
    </div>
  );
}
"
`;

exports[`Export Snapshot Tests > EVM Export Snapshots > should match snapshot for adapters index > adapter-index-evm 1`] = `
"/**
 * Modified adapter index file
 * Only includes the EvmAdapter and the ContractAdapter interface
 */

import EvmAdapter from './evm/adapter';

import type { ContractAdapter, ExecutionConfig, ExecutionMethodDetail } from '@openzeppelin/transaction-form-types/adapters';

// Note: ContractAdapter interface is now imported from @openzeppelin/transaction-form-types/adapters

// Export the selected adapter
export { EvmAdapter };
export type { ContractAdapter, ExecutionConfig, ExecutionMethodDetail };
"
`;

exports[`Export Snapshot Tests > EVM Export Snapshots > should match snapshot for package.json structure > package-json-evm 1`] = `
{
  "dependencies": {
    "@openzeppelin/transaction-form-renderer": "^1.0.0",
    "ethers": "^6.13.5",
    "lodash": "^4.17.21",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.54.2",
    "viem": "^2.28.0",
    "wagmi": "^2.15.0",
  },
  "devDependencies": {
    "@types/lodash": "^4.17.16",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.3",
    "@typescript-eslint/eslint-plugin": "^8.26.0",
    "@typescript-eslint/parser": "^8.26.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.17",
    "eslint": "^9.3.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.35",
    "tailwindcss": "^4.0.0",
    "typescript": "^5.8.2",
    "vite": "^6.2.5",
  },
  "scripts": {
    "build": "tsc && vite build",
    "check-deps": "npm outdated",
    "dev": "vite",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "update-form-renderer": "npm update @openzeppelin/transaction-form-renderer",
  },
}
`;

exports[`Export Snapshot Tests > Solana Export Snapshots > should match snapshot for Solana adapter > solana-adapter 1`] = `
"import { type Connector } from '@openzeppelin/transaction-form-types/adapters';
import type {
  FieldType,
  FieldValue,
  FormFieldType,
} from '@openzeppelin/transaction-form-types/forms';

import type {
  ContractAdapter,
  ContractFunction,
  ContractSchema,
  ExecutionConfig,
  ExecutionMethodDetail,
  FunctionParameter,
} from '../index';

// Explicit relative path

/**
 * Solana-specific adapter implementation
 *
 * NOTE: This is just a minimal placeholder implementation. The project is currently focusing
 * exclusively on the EVM adapter. This adapter will be properly implemented in future phases
 * when we expand support to the Solana blockchain.
 */
export class SolanaAdapter implements ContractAdapter {
  /**
   * Load a contract from a file or address
   *
   * TODO: Implement actual Solana program loading logic in future phases
   */
  async loadContract(source: string): Promise<ContractSchema> {
    console.log(\`[PLACEHOLDER] Loading Solana program from: \${source}\`);
    return this.loadMockContract();
  }

  /**
   * Load a mock contract for testing
   *
   * TODO: Implement proper Solana program schema in future phases
   * @param mockId Optional ID to specify which mock to load (not used for Solana adapter)
   */
  async loadMockContract(_mockId?: string): Promise<ContractSchema> {
    // Simple minimal mock contract schema
    return {
      chainType: 'solana',
      name: 'PlaceholderSolanaProgram',
      functions: [
        {
          id: 'dummy_instruction',
          name: 'placeholderInstruction',
          displayName: 'Placeholder Instruction',
          inputs: [
            {
              name: 'dummyParam',
              type: 'string',
              displayName: 'Dummy Parameter',
            },
          ],
          type: 'function',
          modifiesState: true, // Assume this placeholder instruction modifies state
        },
      ],
    };
  }

  /**
   * Get only the functions that modify state (writable functions)
   * @param contractSchema The contract schema to filter
   * @returns Array of writable functions
   */
  getWritableFunctions(contractSchema: ContractSchema): ContractSchema['functions'] {
    return contractSchema.functions.filter((fn) => fn.modifiesState);
  }

  /**
   * Map a Solana-specific parameter type to a form field type
   *
   * TODO: Implement proper Solana type mapping in future phases
   */
  mapParameterTypeToFieldType(_parameterType: string): FieldType {
    // Placeholder implementation that defaults everything to text fields
    return 'text';
  }

  /**
   * Get field types compatible with a specific parameter type
   * @param _parameterType The blockchain parameter type
   * @returns Array of compatible field types
   *
   * TODO: Implement proper Solana field type compatibility in future phases
   */
  getCompatibleFieldTypes(_parameterType: string): FieldType[] {
    // Placeholder implementation that returns all field types
    return [
      'text',
      'number',
      'checkbox',
      'radio',
      'select',
      'textarea',
      'date',
      'email',
      'password',
      'blockchain-address',
      'amount',
      'hidden',
    ];
  }

  /**
   * Generate default field configuration for a Solana function parameter
   *
   * TODO: Implement proper Solana field generation in future phases
   */
  generateDefaultField<T extends FieldType = FieldType>(
    parameter: FunctionParameter
  ): FormFieldType<T> {
    // Default to text fields for now as a placeholder
    const fieldType = 'text' as T;

    return {
      id: Math.random().toString(36).substring(2, 11),
      name: parameter.name || 'placeholder',
      label: parameter.displayName || parameter.name || 'Placeholder Field',
      type: fieldType,
      placeholder: 'Placeholder - Solana adapter not fully implemented yet',
      helperText: 'Solana adapter is not fully implemented yet',
      defaultValue: '' as FieldValue<T>,
      validation: { required: true },
      width: 'full',
    };
  }

  /**
   * Format transaction data for the specific chain
   *
   * TODO: Implement proper Solana transaction formatting in future phases
   */
  formatTransactionData(
    _functionId: string,
    _submittedInputs: Record<string, unknown>,
    _allFieldsConfig: FormFieldType[]
  ): unknown {
    return { placeholder: 'Solana adapter not implemented yet' };
  }

  /**
   * Sign and broadcast a transaction
   *
   * TODO: Implement proper Solana transaction signing in future phases
   */
  async signAndBroadcast(_transactionData: unknown): Promise<{ txHash: string }> {
    return { txHash: 'solana_placeholder_tx' };
  }

  /**
   * Validate a Solana blockchain address
   * @param address The address to validate
   * @returns Whether the address is a valid Solana address
   */
  isValidAddress(address: string): boolean {
    // Basic check for Solana addresses (Base58 encoded, 32-44 characters)
    // TODO: Use a proper Solana address validation library when focusing on that chain
    return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
  }

  /**
   * @inheritdoc
   * TODO: Implement actual supported methods for Solana (e.g., EOA, Squads).
   */
  async getSupportedExecutionMethods(): Promise<ExecutionMethodDetail[]> {
    // Placeholder: Assume only EOA is supported for now
    console.warn('SolanaAdapter.getSupportedExecutionMethods is using placeholder implementation.');
    return Promise.resolve([
      {
        type: 'eoa',
        name: 'EOA (Wallet Account)',
        description: 'Execute using a standard Solana wallet address.',
      },
      // {
      //   type: 'multisig',
      //   name: 'Squads Protocol',
      //   description: 'Execute via the Squads multisig program.',
      //   disabled: true
      // },
    ]);
  }

  /**
   * @inheritdoc
   * TODO: Implement actual validation logic for Solana execution configs.
   */
  async validateExecutionConfig(config: ExecutionConfig): Promise<true | string> {
    // Placeholder: Basic validation
    console.warn('SolanaAdapter.validateExecutionConfig is using placeholder implementation.');
    if (config.method === 'eoa') {
      if (!config.allowAny && !config.specificAddress) {
        return 'Specific Solana account address is required.';
      }
      if (
        !config.allowAny &&
        config.specificAddress &&
        !this.isValidAddress(config.specificAddress)
      ) {
        return 'Invalid account address format for Solana.';
      }
      return true;
    } else {
      // For now, consider other methods unsupported by this placeholder
      return \`Execution method '\${config.method}' is not yet supported by this adapter implementation.\`;
    }
  }

  /**
   * Determines if a function is a view/pure function (read-only)
   */
  isViewFunction(_functionDetails: ContractFunction): boolean {
    // TODO: Implement properly based on Solana Program types
    return false; // Temporary placeholder
  }

  /**
   * Queries a view function on a contract
   */
  async queryViewFunction(
    _contractAddress: string,
    _functionId: string,
    _params: unknown[] = [],
    _contractSchema?: ContractSchema
  ): Promise<unknown> {
    // TODO: Implement Solana contract query functionality
    throw new Error('Solana view function queries not yet implemented');
  }

  /**
   * Formats a function result for display
   */
  formatFunctionResult(
    result: unknown,
    _functionDetails: ContractFunction
  ): string | Record<string, unknown> {
    // TODO: Implement Solana-specific result formatting
    if (result === null || result === undefined) {
      return 'No data';
    }

    return String(result);
  }

  /**
   * Indicates if this adapter supports wallet connection
   * @returns Whether wallet connection is supported by this adapter
   */
  supportsWalletConnection(): boolean {
    return false; // Solana wallet connection not yet implemented
  }

  async getAvailableConnectors(): Promise<Connector[]> {
    return [];
  }

  async connectWallet(
    _connectorId: string
  ): Promise<{ connected: boolean; address?: string; error?: string }> {
    return { connected: false, error: 'Solana adapter does not support wallet connection.' };
  }

  async disconnectWallet(): Promise<{ disconnected: boolean; error?: string }> {
    return { disconnected: false, error: 'Solana adapter does not support wallet connection.' };
  }

  /**
   * @inheritdoc
   */
  getWalletConnectionStatus(): { isConnected: boolean; address?: string; chainId?: string } {
    // Stub implementation: Always return disconnected status
    return { isConnected: false };
  }

  /**
   * Gets a blockchain explorer URL for an address on Solana
   *
   * @param address The address to get the explorer URL for
   * @param _chainId Optional chain ID (not used for Solana as it uses clusters instead)
   * @returns A URL to view the address on a Solana explorer
   */
  getExplorerUrl(address: string, _chainId?: string): string | null {
    if (!address) return null;

    // Default to Solana explorer for mainnet
    return \`https://explorer.solana.com/address/\${address}\`;
  }
}

// Also export as default to ensure compatibility with various import styles
export default SolanaAdapter;
"
`;

exports[`Export Snapshot Tests > Solana Export Snapshots > should match snapshot for adapters index with Solana > adapter-index-solana 1`] = `
"/**
 * Modified adapter index file
 * Only includes the SolanaAdapter and the ContractAdapter interface
 */

import SolanaAdapter from './solana/adapter';

import type { ContractAdapter, ExecutionConfig, ExecutionMethodDetail } from '@openzeppelin/transaction-form-types/adapters';

// Note: ContractAdapter interface is now imported from @openzeppelin/transaction-form-types/adapters

// Export the selected adapter
export { SolanaAdapter };
export type { ContractAdapter, ExecutionConfig, ExecutionMethodDetail };
"
`;

exports[`Export Snapshot Tests > Solana Export Snapshots > should match snapshot for package.json with Solana dependencies > package-json-solana 1`] = `
{
  "dependencies": {
    "@openzeppelin/transaction-form-renderer": "^1.0.0",
    "@project-serum/anchor": "^0.26.0",
    "@solana/spl-token": "^0.3.8",
    "@solana/wallet-adapter-base": "^0.9.23",
    "@solana/wallet-adapter-react": "^0.15.35",
    "@solana/web3.js": "^1.78.5",
    "bs58": "^5.0.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.54.2",
  },
  "devDependencies": {
    "@solana/cli": "^1.1.0",
    "@solana/spl-token-registry": "^0.2.4574",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.3",
    "@typescript-eslint/eslint-plugin": "^8.26.0",
    "@typescript-eslint/parser": "^8.26.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.17",
    "eslint": "^9.3.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.35",
    "tailwindcss": "^4.0.0",
    "typescript": "^5.8.2",
    "vite": "^6.2.5",
  },
  "scripts": {
    "build": "tsc && vite build",
    "check-deps": "npm outdated",
    "dev": "vite",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "update-form-renderer": "npm update @openzeppelin/transaction-form-renderer",
  },
}
`;
